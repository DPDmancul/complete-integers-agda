\documentclass[a4paper]{report}
\usepackage[hidelinks]{hyperref}
\usepackage[links]{agda}
\usepackage{amsmath, amssymb, mathtools, amsthm, newunicodechar}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand\bN{\mathbb{N}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newcommand\bZ{\mathbb{Z}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}
\newcommand\bF{\mathbb{F}}
\newunicodechar{𝔽}{\ensuremath{\mathbb{F}}}
\newunicodechar{₂}{\ensuremath{_2}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{⦃}{\ensuremath{\{\kern-0.6ex|}}
\newunicodechar{⦄}{\ensuremath{|\kern-0.6ex\}}}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{ˡ}{\ensuremath{^l}}
\newunicodechar{ʳ}{\ensuremath{^r}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{∧}{\ensuremath{\land}}
\newunicodechar{∙}{\ensuremath{\cdot}}
\newunicodechar{⁻}{\ensuremath{^-}}

\title{Complete integers}
\author{Davide Peressoni}
\date{May 2022}

\begin{document}

\maketitle

\begin{code}
-- (c) Davide Peressoni 2022

open import Data.Int
open import Data.F2
open import Relation.Binary.PropositionalEquality
\end{code}

\chapter{Complete integer numbers}

\textbf{TODO} sistemare\\
In this chapter we will define the ring of complete integers ($\bZ_C$) and we will
see that it is a superset of $\bZ$. Then we will call the remaining dis-integers
($\bZ_D$) which are the dual of integers ($\bZ$) along parity (e.g. in $\bZ$ the unit is
odd, in $\bZ_D$ the unit is even).

\begin{definition}[Complete integers prime]
Let's define the set of the complete integer numbers prime as

\[\bZ_C' \coloneqq \bZ\times\bF_2\]

We will call the first component \emph{value}, and the second \emph{parity}.

\begin{code}
record ℤC' : Set where
  constructor [_,_]
  field
    val : ℤ
    par : 𝔽₂
\end{code}
\end{definition}

\begin{definition}[Ring $\bZ_C'$]
Let's define $\bZ_C'$ as a commutative ring with unit:

Given $[a,b], [c,d] \in \bZ_C'$

\[[a,b] + [c,d] \coloneqq [a+c, b\oplus d]\]

\begin{code}
instance
  open import Ops

  SumℤC' : Sum ℤC'
  _+_ ⦃ SumℤC' ⦄ [ a , b ] [ c , d ] = [ a + c , b ⊕ d ]
  additive-zero ⦃ SumℤC' ⦄ = [ 0ℤ , zero ]
  lemma-sum-zero ⦃ SumℤC' ⦄ = cong₂ [_,_] lemma-sum-zero lemma-sum-zero

  SubℤC' : Sub ℤC'
  -_ ⦃ SubℤC' ⦄ [ a , b ] = [ - a , b ]
\end{code}

\[[a,b] \cdot [c,d] \coloneqq [a\cdot c, b\cdot d]\]

\begin{code}
instance
  open import Ops

  MulℤC' : Mul ℤC'
  _·_ ⦃ MulℤC' ⦄ [ a , b ] [ c , d ] = [ a · c , b · d ]
  unit ⦃ MulℤC' ⦄ = [ 1ℤ , one ]
  lemma-unit ⦃ MulℤC' ⦄ = cong₂ [_,_] lemma-unit lemma-unit
\end{code}
\end{definition}

\begin{proof}
  Now let's check if the given definition is valid:
  \begin{code}
module RingℤC' where
  open import Algebra
  import Data.F2.Properties as 𝔽₂p
  import Data.Integer.Properties as ℤp

  ---------------------
  -- Properties of + --
  ---------------------

  +-assoc : (a b c : ℤC') → (a + b) + c ≡ a + (b + c)
  +-assoc [ va , pa ] [ vb , pb ] [ vc , pc ] =
    cong₂ [_,_] (ℤp.+-assoc va vb vc) (𝔽₂p.⊕-assoc pa pb pc)

  +-comm : (a b : ℤC') → a + b ≡ b + a
  +-comm [ va , pa ] [ vb , pb ] =
    cong₂ [_,_] (ℤp.+-comm va vb) (𝔽₂p.⊕-comm pa pb)

  +-identityˡ : (z : ℤC') → additive-zero + z ≡ z
  +-identityˡ _ = lemma-sum-zero
  +-identityʳ : (z : ℤC') → z + additive-zero ≡ z
  +-identityʳ z rewrite (+-comm z additive-zero) = +-identityˡ z

  +-inverseˡ : (z : ℤC') → (- z) + z ≡ additive-zero
  +-inverseˡ [ v , p ] = cong₂ [_,_] (ℤp.+-inverseˡ v) (𝔽₂p.⊕-self p)
  +-inverseʳ : (z : ℤC') → z + (- z) ≡ additive-zero
  +-inverseʳ [ v , p ] = cong₂ [_,_] (ℤp.+-inverseʳ v) (𝔽₂p.⊕-self p)

  ---------------------
  -- Properties of · --
  ---------------------

  ·-assoc : (a b c : ℤC') → (a · b) · c ≡ a · (b · c)
  ·-assoc [ va , pa ] [ vb , pb ] [ vc , pc ] =
    cong₂ [_,_] (ℤp.*-assoc va vb vc) (𝔽₂p.∧-assoc pa pb pc)

  ·-comm : (a b : ℤC') → a · b ≡ b · a
  ·-comm [ va , pa ] [ vb , pb ] =
    cong₂ [_,_] (ℤp.*-comm va vb) (𝔽₂p.∧-comm pa pb)

  ·-identityˡ : (z : ℤC') → unit · z ≡ z
  ·-identityˡ _ = lemma-unit
  ·-identityʳ : (z : ℤC') → z · unit ≡ z
  ·-identityʳ z rewrite (·-comm z unit) = ·-identityˡ z

  ·-distribʳ-+ : (c a b : ℤC') → (a + b) · c ≡ a · c + b · c
  ·-distribʳ-+ [ vc , pc ] [ va , pa ] [ vb , pb ] =
    cong₂ [_,_] (ℤp.*-distribʳ-+ vc va vb) (𝔽₂p.∧-distribʳ-⊕ pc pa pb)
  ·-distribˡ-+ : (c a b : ℤC') → c · (a + b) ≡ c · a + c · b
  ·-distribˡ-+ c a b =
    trans (trans (·-comm c (a + b)) (·-distribʳ-+ c a b))
          (cong₂ _+_  (·-comm a c) (·-comm b c))

  ·-zeroˡ : (a : ℤC') → additive-zero · a ≡ additive-zero
  ·-zeroˡ [ v , p ] = cong₂ [_,_] (ℤp.*-zeroˡ v)  (𝔽₂p.∧-zeroˡ p)
  ·-zeroʳ : (a : ℤC') → a · additive-zero ≡ additive-zero
  ·-zeroʳ a = trans (·-comm a additive-zero) (·-zeroˡ a)

  ----------------
  -- Structures --
  ----------------

  ℤC'-+-isMagma = record
    { isEquivalence = isEquivalence
    ; ∙-cong        =  cong₂ (_+_ ⦃ SumℤC' ⦄)
    }
  ℤC'-·-isMagma = record
    { isEquivalence = isEquivalence
    ; ∙-cong        =  cong₂ (_·_ ⦃ MulℤC' ⦄)
    }

  ℤC'-+-isSemigroup = record
    { isMagma = ℤC'-+-isMagma
    ; assoc   = +-assoc
    }
  ℤC'-·-isSemigroup = record
    { isMagma = ℤC'-·-isMagma
    ; assoc   = ·-assoc
    }

  ℤC'-+-isMonoid = record
    { isSemigroup = ℤC'-+-isSemigroup
    ; identity    = +-identityˡ , +-identityʳ
    }
    where open import Agda.Builtin.Sigma
  ℤC'-·-isMonoid = record
    { isSemigroup = ℤC'-·-isSemigroup
    ; identity    = ·-identityˡ , ·-identityʳ
    }
    where open import Agda.Builtin.Sigma

  ℤC'-+-isGroup = record
    { isMonoid = ℤC'-+-isMonoid
    ; inverse  = +-inverseˡ , +-inverseʳ
    ; ⁻¹-cong  = cong (-_)
    }
    where open import Agda.Builtin.Sigma

  ℤC'-+-isAbelianGroup = record
    { isGroup = ℤC'-+-isGroup
    ; comm    = +-comm
    }

  ℤC'-isRing = record
    { +-isAbelianGroup = ℤC'-+-isAbelianGroup
    ; *-isMonoid       = ℤC'-·-isMonoid
    ; distrib          = ·-distribˡ-+ , ·-distribʳ-+
    ; zero             = ·-zeroˡ , ·-zeroʳ
    }
    where open import Agda.Builtin.Sigma

  ℤC'-isCommRing = record
    { isRing = ℤC'-isRing
    ; *-comm = ·-comm
    }

  \end{code}
\end{proof}

\end{document}

