\documentclass[a4paper]{report}
\usepackage[hidelinks]{hyperref}
\usepackage[links]{agda}
\usepackage{amsmath, amssymb, mathtools, amsthm, newunicodechar}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand\bN{\mathbb{N}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newcommand\bZ{\mathbb{Z}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}
\newcommand\bF{\mathbb{F}}
\newunicodechar{𝔽}{\ensuremath{\mathbb{F}}}
\newunicodechar{₂}{\ensuremath{_2}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{⦃}{\ensuremath{\{\kern-0.6ex|}}
\newunicodechar{⦄}{\ensuremath{|\kern-0.6ex\}}}
\newunicodechar{λ}{\ensuremath{\lambda}}

\title{Complete integers}
\author{Davide Peressoni}
\date{May 2022}

\begin{document}

\maketitle

\begin{code}
-- (c) Davide Peressoni 2022

open import Data.Int
open import Data.F2
open import Relation.Binary.PropositionalEquality
\end{code}

\chapter{Complete integer numbers}

\textbf{TODO} sistemare\\
In this chapter we will define the ring of complete integers ($\bZ_C$) and we will
see that it is a superset of $\bZ$. Then we will call the remaining dis-integers
($\bZ_D$) which are the dual of integers ($\bZ$) along parity (e.g. in $\bZ$ the unit is
odd, in $\bZ_D$ the unit is even).

\begin{definition}[Complete integers prime]
Let's define the set of the complete integer numbers prime as

\[\bZ_C' \coloneqq \bZ\times\bF_2\]

We will call the first component \emph{value}, and the second \emph{parity}.

\begin{code}
record ℤC' : Set where
  constructor [_,_]
  field
    val : ℤ
    par : 𝔽₂
\end{code}
\end{definition}

\begin{definition}[Ring $\bZ_C'$]
Let's define $\bZ_C'$ as a commutative ring with unit:

Given $[a,b], [c,d] \in \bZ_C'$

\[[a,b] + [c,d] \coloneqq [a+c, b\oplus d]\]

\begin{code}
instance
  open import Ops
  SumℤC' : Sum ℤC'
  _+_ ⦃ SumℤC' ⦄ [ a , b ] [ c , d ] = [ a + c , b ⊕ d ]
  additive-zero ⦃ SumℤC' ⦄ = [ 0ℤ , zero ]
  lemma-sum-zero ⦃ SumℤC' ⦄ = cong₂ [_,_] (lemma-sum-zero Sumℤ) (lemma-sum-zero Sum𝔽₂)
\end{code}

\[[a,b] \cdot [c,d] \coloneqq [a\cdot c, b\cdot d]\]

\begin{code}
instance
  open import Ops
  MulℤC' : Mul ℤC'
  _·_ ⦃ MulℤC' ⦄ [ a , b ] [ c , d ] = [ a · c , b · d ]
  unit ⦃ MulℤC' ⦄ = [ 1ℤ , one ]
  lemma-unit ⦃ MulℤC' ⦄ = cong₂ [_,_] lemma-unit lemma-unit
\end{code}
\end{definition}

\begin{proof}
  Now let's check if the given definition is valid:
  \begin{code}
module _ where
  open import Algebra
  open import Agda.Builtin.Sigma
  import Data.Bool.Properties as 𝔽₂p
  import Data.Integer.Properties as ℤp

  ℤC'-isMagma = record
    { isEquivalence = {! IsEquivalence _≡_ !}
    ; ∙-cong        = {!   !}
    }
  ℤC'-isSemigroup = record
    { isMagma = ℤC'-isMagma
      ; assoc   = λ [ a , b ] [ c , d ] [ e , f ] → cong₂ [_,_] (ℤp.+-assoc a c e) (𝔽₂p.∨-assoc b d f)
    }
  ℤC'-isMonoid = record
    { isSemigroup = ℤC'-isSemigroup
    ; identity    = (λ [ v , p ] → cong₂ [_,_] (ℤp.+-identityˡ v) (𝔽₂p.∨-identityˡ p)) , λ [ v , p ] → cong₂ [_,_] (ℤp.+-identityʳ v) (𝔽₂p.∨-identityʳ p)
    }
  ℤC'-isGroup = record
    { isMonoid = ℤC'-isMonoid
    ; inverse  = (λ [ v , p ] → cong₂ [_,_] (ℤp.+-inverseˡ v) (𝔽₂p.∨-inverseˡ p)) , λ [ v , p ] → cong₂ [_,_] (ℤp.+-inverseʳ v) (𝔽₂p.∨-inverseʳ p)
    ; ⁻¹-cong  = λ _ → cong₂ [_,_] refl refl
    }
  ℤC'-isAbelianGroup = record
    { isGroup = ℤC'-isGroup
    ; comm    = λ [ a , b ] [ c , d ] → cong₂ [_,_] (ℤp.+-comm a c) (𝔽₂p.∨-comm b d)
    }
  ℤC'-isRing = record
    { +-isAbelianGroup = ℤC'-isAbelianGroup
    --; *-cong = ?
    --; *-assoc = ?
    --; *-identity = ?
    --; distrib = ?
    --; zero = ?
    }
  ℤC'-isCommRing = record
    { isRing = ℤC'-isRing
    ; *-comm = λ [ a , b ] [ c , d ] → cong₂ [_,_] (ℤp.*-comm a c) (𝔽₂p.∧-comm b d)
    }

  \end{code}
\end{proof}

\end{document}

