\documentclass[a4paper]{report}
\usepackage[hidelinks]{hyperref}
\usepackage[links]{agda}
\usepackage{amsmath, amssymb, mathtools, amsthm, newunicodechar}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand\bN{\mathbb{N}}
\newunicodechar{â„•}{\ensuremath{\mathbb{N}}}
\newcommand\bZ{\mathbb{Z}}
\newunicodechar{â„¤}{\ensuremath{\mathbb{Z}}}
\newcommand\bF{\mathbb{F}}
\newunicodechar{ğ”½}{\ensuremath{\mathbb{F}}}
\newunicodechar{â‚‚}{\ensuremath{_2}}
\newunicodechar{âŠ•}{\ensuremath{\oplus}}
\newunicodechar{â¦ƒ}{\ensuremath{\{\kern-0.6ex|}}
\newunicodechar{â¦„}{\ensuremath{|\kern-0.6ex\}}}
\newunicodechar{Î»}{\ensuremath{\lambda}}
\newunicodechar{Ë¡}{\ensuremath{^l}}
\newunicodechar{Ê³}{\ensuremath{^r}}
\newunicodechar{â‰¡}{\ensuremath{\equiv}}
\newunicodechar{âˆ§}{\ensuremath{\land}}
\newunicodechar{âˆ™}{\ensuremath{\cdot}}
\newunicodechar{â»}{\ensuremath{^-}}

\title{Complete integers}
\author{Davide Peressoni}
\date{May 2022}

\begin{document}

\maketitle

\begin{code}
-- (c) Davide Peressoni 2022

open import Data.Int
open import Data.F2
open import Relation.Binary.PropositionalEquality
\end{code}

\chapter{Complete integer numbers}

\textbf{TODO} sistemare\\
In this chapter we will define the ring of complete integers ($\bZ_C$) and we will
see that it is a superset of $\bZ$. Then we will call the remaining dis-integers
($\bZ_D$) which are the dual of integers ($\bZ$) along parity (e.g. in $\bZ$ the unit is
odd, in $\bZ_D$ the unit is even).

\begin{definition}[Complete integers prime]
Let's define the set of the complete integer numbers prime as

\[\bZ_C' \coloneqq \bZ\times\bF_2\]

We will call the first component \emph{value}, and the second \emph{parity}.

\begin{code}
record â„¤C' : Set where
  constructor [_,_]
  field
    val : â„¤
    par : ğ”½â‚‚
\end{code}
\end{definition}

\begin{definition}[Ring $\bZ_C'$]
Let's define $\bZ_C'$ as a commutative ring with unit:

Given $[a,b], [c,d] \in \bZ_C'$

\[[a,b] + [c,d] \coloneqq [a+c, b\oplus d]\]

\begin{code}
instance
  open import Ops

  Sumâ„¤C' : Sum â„¤C'
  _+_ â¦ƒ Sumâ„¤C' â¦„ [ a , b ] [ c , d ] = [ a + c , b âŠ• d ]
  additive-zero â¦ƒ Sumâ„¤C' â¦„ = [ 0â„¤ , zero ]
  lemma-sum-zero â¦ƒ Sumâ„¤C' â¦„ = congâ‚‚ [_,_] (lemma-sum-zero Sumâ„¤) (lemma-sum-zero Sumğ”½â‚‚)

  Subâ„¤C' : Sub â„¤C'
  -_ â¦ƒ Subâ„¤C' â¦„ [ a , b ] = [ - a , b ]
\end{code}

\[[a,b] \cdot [c,d] \coloneqq [a\cdot c, b\cdot d]\]

\begin{code}
instance
  open import Ops

  Mulâ„¤C' : Mul â„¤C'
  _Â·_ â¦ƒ Mulâ„¤C' â¦„ [ a , b ] [ c , d ] = [ a Â· c , b Â· d ]
  unit â¦ƒ Mulâ„¤C' â¦„ = [ 1â„¤ , one ]
  lemma-unit â¦ƒ Mulâ„¤C' â¦„ = congâ‚‚ [_,_] lemma-unit lemma-unit
\end{code}
\end{definition}

\begin{proof}
  Now let's check if the given definition is valid:
  \begin{code}
module Ringâ„¤C' where
  open import Algebra
  import Data.F2.Properties as ğ”½â‚‚p
  import Data.Integer.Properties as â„¤p

  ----------------------
  -- Propoerties of + --
  ----------------------

  +-assoc : (a b c : â„¤C') â†’ (a + b) + c â‰¡ a + (b + c)
  +-assoc [ va , pa ] [ vb , pb ] [ vc , pc ] = congâ‚‚ [_,_] (â„¤p.+-assoc va vb vc) (ğ”½â‚‚p.âŠ•-assoc pa pb pc)

  +-comm : (a b : â„¤C') â†’ a + b â‰¡ b + a
  +-comm [ va , pa ] [ vb , pb ] = congâ‚‚ [_,_] (â„¤p.+-comm va vb) (ğ”½â‚‚p.âŠ•-comm pa pb)

  +-identityË¡ : (z : â„¤C') â†’ (additive-zero Sumâ„¤C') + z â‰¡ z
  +-identityË¡ _ = lemma-sum-zero Sumâ„¤C'
  +-identityÊ³ : (z : â„¤C') â†’ z + (additive-zero Sumâ„¤C') â‰¡ z
  +-identityÊ³ z = trans (+-comm z (additive-zero Sumâ„¤C')) (+-identityË¡ z)

  +-inverseË¡ : (z : â„¤C') â†’ (- z) + z â‰¡ (additive-zero Sumâ„¤C')
  +-inverseË¡ [ v , p ] = congâ‚‚ [_,_] (â„¤p.+-inverseË¡ v) (ğ”½â‚‚p.âŠ•-self p)
  +-inverseÊ³ : (z : â„¤C') â†’ z + (- z) â‰¡ (additive-zero Sumâ„¤C')
  +-inverseÊ³ [ v , p ] = congâ‚‚ [_,_] (â„¤p.+-inverseÊ³ v) (ğ”½â‚‚p.âŠ•-self p)

  ----------------------
  -- Propoerties of Â· --
  ----------------------

  Â·-comm : (a b : â„¤C') â†’ a Â· b â‰¡ b Â· a
  Â·-comm [ va , pa ] [ vb , pb ] = congâ‚‚ [_,_] (â„¤p.*-comm va vb) (ğ”½â‚‚p.âˆ§-comm pa pb)

  ----------------
  -- Structures --
  ----------------

  â„¤C'-isMagma = record
    { isEquivalence = isEquivalence
    ; âˆ™-cong        =  congâ‚‚ (_+_ â¦ƒ Sumâ„¤C' â¦„)
    }
  â„¤C'-isSemigroup = record
    { isMagma = â„¤C'-isMagma
    ; assoc   = +-assoc
    }
  â„¤C'-isMonoid = record
    { isSemigroup = â„¤C'-isSemigroup
    ; identity    = +-identityË¡ , +-identityÊ³
    }
    where open import Agda.Builtin.Sigma
  â„¤C'-isGroup = record
    { isMonoid = â„¤C'-isMonoid
    ; inverse  = +-inverseË¡ , +-inverseÊ³
    ; â»Â¹-cong  = cong (-_)
    }
    where open import Agda.Builtin.Sigma
  â„¤C'-isAbelianGroup = record
    { isGroup = â„¤C'-isGroup
    ; comm    = +-comm
    }
  -- â„¤C'-isRing = record
  --   { +-isAbelianGroup = â„¤C'-isAbelianGroup
  --   ; *-isMonoid       = {!   !}
  --   ; distrib          = {!   !}
  --   ; zero             = {!   !}
  --   }
  -- â„¤C'-isCommRing = record
  --   { isRing = {!   !} --â„¤C'-isRing
  --   ; *-comm = Â·-comm
  --   }

  \end{code}
\end{proof}

\end{document}

