\documentclass[a4paper]{report}
\usepackage[hidelinks]{hyperref}
\usepackage[links]{agda}
\usepackage{amsmath, amssymb, mathtools, amsthm, newunicodechar}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand\bN{\mathbb{N}}
\newunicodechar{â„•}{\ensuremath{\mathbb{N}}}
\newcommand\bZ{\mathbb{Z}}
\newunicodechar{â„¤}{\ensuremath{\mathbb{Z}}}
\newcommand\bF{\mathbb{F}}
\newunicodechar{ğ”½}{\ensuremath{\mathbb{F}}}
\newunicodechar{â‚‚}{\ensuremath{_2}}
\newunicodechar{âŠ•}{\ensuremath{\oplus}}
\newunicodechar{â¦ƒ}{\ensuremath{\{\kern-0.6ex|}}
\newunicodechar{â¦„}{\ensuremath{|\kern-0.6ex\}}}
\newunicodechar{Î»}{\ensuremath{\lambda}}

\title{Complete integers}
\author{Davide Peressoni}
\date{May 2022}

\begin{document}

\maketitle

\begin{code}
-- (c) Davide Peressoni 2022

open import Data.Int
open import Data.F2
open import Relation.Binary.PropositionalEquality
\end{code}

\chapter{Complete integer numbers}

\textbf{TODO} sistemare\\
In this chapter we will define the ring of complete integers ($\bZ_C$) and we will
see that it is a superset of $\bZ$. Then we will call the remaining dis-integers
($\bZ_D$) which are the dual of integers ($\bZ$) along parity (e.g. in $\bZ$ the unit is
odd, in $\bZ_D$ the unit is even).

\begin{definition}[Complete integers prime]
Let's define the set of the complete integer numbers prime as

\[\bZ_C' \coloneqq \bZ\times\bF_2\]

We will call the first component \emph{value}, and the second \emph{parity}.

\begin{code}
record â„¤C' : Set where
  constructor [_,_]
  field
    val : â„¤
    par : ğ”½â‚‚
\end{code}
\end{definition}

\begin{definition}[Ring $\bZ_C'$]
Let's define $\bZ_C'$ as a commutative ring with unit:

Given $[a,b], [c,d] \in \bZ_C'$

\[[a,b] + [c,d] \coloneqq [a+c, b\oplus d]\]

\begin{code}
instance
  open import Ops
  Sumâ„¤C' : Sum â„¤C'
  _+_ â¦ƒ Sumâ„¤C' â¦„ [ a , b ] [ c , d ] = [ a + c , b âŠ• d ]
  additive-zero â¦ƒ Sumâ„¤C' â¦„ = [ 0â„¤ , zero ]
  lemma-sum-zero â¦ƒ Sumâ„¤C' â¦„ = congâ‚‚ [_,_] (lemma-sum-zero Sumâ„¤) (lemma-sum-zero Sumğ”½â‚‚)
\end{code}

\[[a,b] \cdot [c,d] \coloneqq [a\cdot c, b\cdot d]\]

\begin{code}
instance
  open import Ops
  Mulâ„¤C' : Mul â„¤C'
  _Â·_ â¦ƒ Mulâ„¤C' â¦„ [ a , b ] [ c , d ] = [ a Â· c , b Â· d ]
  unit â¦ƒ Mulâ„¤C' â¦„ = [ 1â„¤ , one ]
  lemma-unit â¦ƒ Mulâ„¤C' â¦„ = congâ‚‚ [_,_] lemma-unit lemma-unit
\end{code}
\end{definition}

\begin{proof}
  Now let's check if the given definition is valid:
  \begin{code}
module _ where
  open import Algebra
  open import Agda.Builtin.Sigma
  import Data.Bool.Properties as ğ”½â‚‚p
  import Data.Integer.Properties as â„¤p

  â„¤C'-isMagma = record
    { isEquivalence = {! IsEquivalence _â‰¡_ !}
    ; âˆ™-cong        = {!   !}
    }
  â„¤C'-isSemigroup = record
    { isMagma = â„¤C'-isMagma
      ; assoc   = Î» [ a , b ] [ c , d ] [ e , f ] â†’ congâ‚‚ [_,_] (â„¤p.+-assoc a c e) (ğ”½â‚‚p.âˆ¨-assoc b d f)
    }
  â„¤C'-isMonoid = record
    { isSemigroup = â„¤C'-isSemigroup
    ; identity    = (Î» [ v , p ] â†’ congâ‚‚ [_,_] (â„¤p.+-identityË¡ v) (ğ”½â‚‚p.âˆ¨-identityË¡ p)) , Î» [ v , p ] â†’ congâ‚‚ [_,_] (â„¤p.+-identityÊ³ v) (ğ”½â‚‚p.âˆ¨-identityÊ³ p)
    }
  â„¤C'-isGroup = record
    { isMonoid = â„¤C'-isMonoid
    ; inverse  = (Î» [ v , p ] â†’ congâ‚‚ [_,_] (â„¤p.+-inverseË¡ v) (ğ”½â‚‚p.âˆ¨-inverseË¡ p)) , Î» [ v , p ] â†’ congâ‚‚ [_,_] (â„¤p.+-inverseÊ³ v) (ğ”½â‚‚p.âˆ¨-inverseÊ³ p)
    ; â»Â¹-cong  = Î» _ â†’ congâ‚‚ [_,_] refl refl
    }
  â„¤C'-isAbelianGroup = record
    { isGroup = â„¤C'-isGroup
    ; comm    = Î» [ a , b ] [ c , d ] â†’ congâ‚‚ [_,_] (â„¤p.+-comm a c) (ğ”½â‚‚p.âˆ¨-comm b d)
    }
  â„¤C'-isRing = record
    { +-isAbelianGroup = â„¤C'-isAbelianGroup
    --; *-cong = ?
    --; *-assoc = ?
    --; *-identity = ?
    --; distrib = ?
    --; zero = ?
    }
  â„¤C'-isCommRing = record
    { isRing = â„¤C'-isRing
    ; *-comm = Î» [ a , b ] [ c , d ] â†’ congâ‚‚ [_,_] (â„¤p.*-comm a c) (ğ”½â‚‚p.âˆ§-comm b d)
    }

  \end{code}
\end{proof}

\end{document}

